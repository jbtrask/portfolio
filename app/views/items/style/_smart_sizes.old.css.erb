

 [GRID_MIN, (GRID_MIN.to_f * GRID_ASPECT_RATIO).round] ]


	vertical = [ VERTICAL_MIN ]
	until vertical.last + VERTICAL_INCREMENT > VERTICAL_MAX do
		vertical << vertical.last + VERTICAL_INCREMENT
	end
	corrected_v = vertical.map{|size| (size * (1.0 + v_correct.to_f / 100.0)).floor }
	vertical << nil
	
	horizontal = [ HORIZONTAL_MIN ]
	until horizontal.last + HORIZONTAL_INCREMENT > HORIZONTAL_MAX do
		horizontal << horizontal.last + HORIZONTAL_INCREMENT
	end
	corrected_h = horizontal.map{|size| (size * (1.0 + h_correct.to_f / 100.0)).floor }
	horizontal << nil
	
	regions = {}
	vertical.each_with_index do |v, v_idx|
		horizontal.each_with_index do |h, h_idx|

			grid_size = sizes.first
			target_rows = rows.nil? ? nil : rows
			target_columns = columns.nil? ? nil : columns
			if target_rows.nil? && target_columns.nil? 
				# best fit both directions
			elsif target_rows.nil? || target_columns.nil?
				if target_rows.nil?
					sizes.each do |size|
						grid_size = size if h_idx == 0 || size[0] * target_columns + 3 * GRID_SPACING * (target_columns - 1) < horizontal[h_idx - 1]
					end
					target_rows = v_idx == 0 ? 1 :((vertical[v_idx - 1].to_f + 3.0 * GRID_SPACING.to_f) / (grid_size[1].to_f + 3.0 * GRID_SPACING.to_f)).floor
					target_rows = target_rows == 0 ? 1 : target_rows
				else
					sizes.each do |size|
						grid_size = size if v_idx == 0 || size[1] * target_rows + 3 * GRID_SPACING * (target_rows - 1) < vertical[v_idx - 1]
					end
					target_columns = h_idx == 0 ? 1 : ((horizontal[h_idx - 1].to_f + 3.0 * GRID_SPACING.to_f) / (grid_size[0].to_f + 3.0 * GRID_SPACING.to_f)).floor
					target_columns = target_columns == 0 ? 1 : target_columns
				end				
			else
				sizes.each do |size|
					grid_size = size if (h_idx == 0 || size[0] * target_columns + 3 * GRID_SPACING * (target_columns - 1) < horizontal[h_idx - 1]) && (v_idx == 0 || size[1] * target_rows + 3 * GRID_SPACING * (target_rows - 1) < vertical[v_idx - 1])
				end
			end

			media_query = "only screen" + (v_idx == 0 ? "" : " and (min-height: " + (corrected_v[v_idx - 1] + 1).to_s + "px)") + (v.nil? ? "" : " and (max-height: " + corrected_v[v_idx].to_s + "px)") + (h_idx == 0 ? "" : " and (min-width: " + (corrected_h[h_idx - 1] + 1).to_s + "px)") + (h.nil? ? "" : " and (max-width: " + corrected_h[h_idx].to_s + "px)") 
			
			key = grid_size[0].to_s + "|" + grid_size[1].to_s + "|" + target_rows.to_s + "|" + target_columns.to_s
			regions[key] ||= { :grid_size => grid_size, :target_rows => target_rows, :target_columns => target_columns, :media => "" }
			regions[key][:media] += (regions[key][:media] == "" ? "" : ",\n") + media_query

		end
	end

	regions.each do |key, region|

		right_list = bottom_list = ""
		(0..ITEM_COUNT  - 1).each do |i|
			right_list += (right_list == "" ? "" : ", ") + "li#grid_cell_" + i.to_s if (i + 1) % region[:target_columns] == 0
			bottom_list += (bottom_list == "" ? "" : ", ") + "li#grid_cell_" + i.to_s if ((i + 1).to_f / region[:target_columns].to_f).ceil % region[:target_rows] == 0 
		end
%>

@media <%= region[:media] %> {

	div#main ul {
		width: <%= region[:grid_size][0] * region[:target_columns] + GRID_SPACING * (region[:target_columns] - 1) %>px;
		min-width: <%= region[:grid_size][0] * region[:target_columns] + GRID_SPACING * (region[:target_columns] - 1) %>px;
		height: <%= region[:grid_size][1] * region[:target_rows] + GRID_SPACING * (region[:target_rows] - 1) %>px;
		min-height: <%= region[:grid_size][1] * region[:target_rows] + GRID_SPACING * (region[:target_rows] - 1) %>px;
	}

	.grid_cell {
		width: <%= region[:grid_size][0] %>px;
		min-width: <%= region[:grid_size][0] %>px;
		height: <%= region[:grid_size][1] %>px;
		min-height: <%= region[:grid_size][1] %>px;
		margin: 0 <%= GRID_SPACING %>px <%= GRID_SPACING %>px 0
	}
	#h-size:after {
		content: "width:  <%= region[:grid_size][0] %> (<%= region[:target_columns] %>)"
	}
	#v-size:after {
		content: "height:  <%= region[:grid_size][1] %> (<%= region[:target_rows] %>)"
	}
}		

<%= right_list %> {
	margin-right: 0
}
<%= bottom_list %> {
	margin-bottom: 0
}
<% end %>
